diff --git a/Common/Test/cti.py b/Common/Test/cti.py
index cbb0f36..9a5794c 100755
--- a/Common/Test/cti.py
+++ b/Common/Test/cti.py
@@ -268,20 +268,33 @@ class cti(unittest.TestCase):
 
     def check_listen(self, port, ipv6=False):
         '''Check for a particular port being listened on'''
-        if sys.platform == 'darwin':
-            r = re.compile(rf'\.{port} .* LISTEN')
-        else:
-            r = re.compile(rf':{port} .* LISTEN')
-        if sys.platform.startswith("win") and ipv6:
-            cmd = 'netstat -an -p TCPv6'
-        elif sys.platform.startswith("win") or sys.platform == 'darwin':
-            cmd = 'netstat -an -p TCP'
-        else:
-            cmd = 'netstat -ant'
         def test():
-            netstat = Popen(cmd, shell=True, stdout=PIPE)
-            stdout = netstat.communicate()[0].decode('utf8').split('\n')
-            return any(r.search(line) for line in stdout)
+            Connected = False
+            rc = False
+            #oprint(f"Initial entry test for {port}")
+            try:
+                try:
+                    Socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) #Create a socket.
+                except:
+                    Connected = False
+
+                Socket.connect(("127.0.0.1", port)) #Try connect the port. If port is not listening, throws ConnectionRefusedError.
+                #print(f"Connected to {port}")
+                Connected = True
+            except ConnectionRefusedError:
+                #print('Connection Refused')
+                Connected = False
+            finally:
+                socketPort = Socket.getsockname()[1]
+                if (Connected and port != socketPort): #If connected,
+                    rc = True
+                    Socket.close() #Close socket.
+                    #print(f"All good: {Connected} Port {port} Socket Port {socketPort}")
+                else:
+                    #print(f"Connected {Connected} Port {port}")
+                    rc = False
+            return rc
+
         self.try_until(test, 2, f"Port {port} is not bound")
 
     def wait_for_pty_output(self, timeout: int, fd: int, text: str):
